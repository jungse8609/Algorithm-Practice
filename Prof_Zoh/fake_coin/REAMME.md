# Fake coin

---

**[문제]** 

 똑같은 모양의 금화 21개가 있는데 이 중에서 약간 가벼운 가짜 금화가 1개 있음을 알고 있다. 우리는 양팔저울(balance scale)을 이용해서 이 가짜 금화를 찾아내려고 한다. 이때 양팔저울을 최소한으로 사용하여 가짜 금화를 찾아내는 것이 목표이다. 

 여러분은 저울을 대신하는 내장 함수 int balance(int left[], int right[])만을 사용하여 가짜 금화를 찾아내야 한다. 21개의 금화는 정수 {1,2,...21}로 표시된다.

 양팔저울의 왼쪽과 오른쪽 접시에 올린 동전은 두 개의 정수 배열 int left[22], int right[22]로 표시한다. i번째 동전을 왼쪽(오른쪽)에 올릴 경우 left[i]=1(right[i]=1)로 표시한다. 예를 들어, 왼쪽 저울에 {3,4,9,10}, 오른쪽 저울에 {1,12,13,15}를 올려서 측정한다면 두 배열은 다음과 같이 준비되어야 한다. 배열의 빈 곳에는 0이 저장된다.

| index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| **left[22]** |  |  | 1 | 1 |  | 1 |  |  |  | 1 | 1 |  |  |  |  |  |  |  |  |  |  |  |
| **right[22]** | 1 |  |  |  |  |  |  |  | 1 |  | 1 |  |  | 1 |  | 1 |  |  |  |  |  |  |

이 측정 함수 int balance()는 만약 동일한 동전을 양쪽에 올리거나, {0,1} 이외의 숫자가 사용된 경우 프로그램은 즉시 종료되며 1회 시행으로 계산된다. 즉, 아래와 같이 동작한다.

| `int balance()` 값 | 의미 |
| --- | --- |
| **+1** | 왼쪽(`left`)이 더 무거움 |
| **0** | 양쪽 무게가 같음 |
| **-1** | 오른쪽(`right`)이 더 무거움 |
| **999** | 기타 오류 |

 여러분은 int balance() 함수만을 사용하여 가짜 동전을 찾아야 한다. 가짜 동전을 찾으면 void report_coin(i)를 호출하여 보고해야 하며, 이 함수 호출 시 프로그램은 종료된다. 이 문제에서는 별도의 입출력 파일이 없으며, 반드시 헤더 라이브러리를 포함해야 한다. 시스템이 지정한 횟수 이상으로 int balance()를 호출하면 프로그램은 자동으로 종료된다.

 프로그램의 전처리기 부분에 fakecoin.h를 포함해야 한다. 이 헤더 파일에는 전역변수 int left[22], right[22]가 선언되어 있다. 프로그램 시작 시 load_coins()를 호출하여 입력을 완료한 후, balance(int left[], int right[])를 사용하여 가짜 동전을 찾아 보고해야 한다.

```cpp
#include "fakecoin.h" // 반드시 포함
int main() {
    load_coins(); // 입력을 위해서 제일 먼저 호출

		......
		report_coin(i); // 이 함수를 부르면 종료됨
}
```

**[입출력]** 

 소스 프로그램의 시작 부분 헤더에 "fakecoin.h"를 반드시 #include로 포함해야 한다. 이 문제에서는 직접 stdin이나 stdout 파일을 조작하지 않는다.

**[제한조건]** 

 이 문제는 C/C++로만 해결 가능하다. 파일명은 fakecoin.{c, cpp}이며, 제출 횟수와 마감, 최대 token 개수는 NESPA에서 확인할 수 있다. NESPA 문제 게시판에서 "fakecoin.h"를 제공받을 수 있으며, 이를 통해 답안을 검증할 수 있다. 단, 실제 평가에 사용되는 헤더 파일과는 다르다.